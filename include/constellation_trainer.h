#ifndef _CONSTELLATION_TRAINER_H_
#define _CONSTELLATION_TRAINER_H_

#include "./constellation_commons.h"
#include "ps/ps.h"
#include "./internal/engine.h"
#include "./internal/CArray.h"
#include <atomic>
#include <cmath>

namespace constellation {

// TODO: now only support default push pull
enum class RequestType { kDefaultPushPull, kDefaultInit, kRowSparsePushPull, kCompressedPushPull };

struct DataHandleType {
  RequestType requestType;
  int dtype;
};

/*!
 * Refer to MXNet
 * Uses Cantor pairing function to generate a unique number given two numbers.
 * This number can also be inverted to find the unique pair whose Cantor value is this number.
 * Ref: https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function
 * \param requestType RequestType
 * \param dtype integer
 * \return Cantor value of arguments
 */
static int GetCommandType(RequestType type, int d) {
  int m = static_cast<int>(type);
  return (((m + d) * (m + d + 1)) / 2) + d;
};

/*!
 * Refer to MXNet
 * Unpairs Cantor value and finds the two integers used to pair.
 * Then returns DataHandleType object with those numbers.
 * \param cmd DataHandleCommand generated by GetCommandType function
 * \return DataHandleType
 */
static DataHandleType DepairDataHandleType(int cmd) {
  int w = std::floor((std::sqrt(8 * cmd + 1) - 1) / 2);
  int t = ((w * w) + w) / 2;
  int y = cmd - t;
  int x = w - y;
  CHECK_GE(x, 0);
  CHECK_GE(y, 0);
  DataHandleType type;
  type.requestType = static_cast<RequestType>(x);
  type.dtype = y;
  return type;
};

class ConstelTrainer {
 public:
  explicit ConstelTrainer() {
    ps::StartAsync(0, "ConstelTrainer");
    this->trainer_ = new ps::KVTrainer<char>(0, 0);  // app_id, customer_id
    using namespace std::placeholders;
    static_cast<ps::SimpleApp*>(this->trainer_)
        ->set_request_handle(std::bind(&ConstelTrainer::RequestHandle, this, _1, _2));
    this->trainer_->set_request_handle(std::bind(&ConstelTrainer::DataHandle, this, _1, _2, _3));
    InitEngine(2);
  }
  ~ConstelTrainer() {
    ps::Finalize(0, false);
    delete this->trainer_;
    this->trainer_ = nullptr;
    engine_->Stop();
    delete engine_;
  }
  inline bool isRootNode() const {
    auto type = GetNodeType();
    CHECK(type != NodeTransTopo::Type::kUnset);
    return type == NodeTransTopo::Type::kRoot;
  }
  inline bool isLeafNode() const {
    auto type = GetNodeType();
    CHECK(type != NodeTransTopo::Type::kUnset);
    return type == NodeTransTopo::Type::kLeaf;
  }

  inline int NumTrainers() const {
    return ps::Postoffice::Get()->num_trainers();
  }

  inline int myRank() const {
    return ps::Postoffice::Get()->myRank();
  }

  void NotifyReadyAndWait();

  void Broadcast(std::vector<int>& keys, std::vector<CArray*>& vals_init);

  void PushPull(std::vector<int>& keys,
                std::vector<CArray>& vals_push,
                std::vector<CArray*>& vals_pull);

 private:
  /**
   * struct UpdateBuf
   * @brief store the request meta  and merged gradient
   */
  struct UpdateBuf {
    std::vector<ps::KVMeta> request_meta;
    CArray merged;
    size_t num = 0;
    bool shouldReset = false;
    void ResetUpdateBuf() {
      if (shouldReset) {
        request_meta.clear();
        num = 0;
        shouldReset = false;
      }
    }
  };

  enum class TaskTypeEnum {
    kPushPull,
    kBroadcastDefault,
  };

  struct EngineTaskData {
    UpdateBuf update_buf;
    TaskTypeEnum type;
    bool isFromRoot = false;
  };

  /**
   * \brief update_buf_ is used to store the request meta from the son(include itself) and merged
   * gradient
   */
  std::unordered_map<int, UpdateBuf> update_buf_;

  std::unordered_map<int, int> init_waiting_ts_;

  using Engine = ConstelAggEngine<EngineTaskData, int>;

  ScaleClock clock_;

  NodeTransTopo trans_topo_;

  ps::KVTrainer<char>* trainer_;

  std::atomic<bool> is_ctx_ready_{false};

  bool is_scale_ = true;

  mutable std::mutex update_buf_mu_;

  mutable std::mutex trans_topo_mu_;

  mutable std::mutex init_waiting_ts_mu_;

  Engine* engine_;

  UpdateBuf* GetUpdateBuf(int key) {
    std::lock_guard<std::mutex> lock(update_buf_mu_);
    return &update_buf_[key];
  }
  inline auto& GetNodeTransTopo() {
    std::unique_lock<std::mutex> lock(trans_topo_mu_);
    return trans_topo_;
  }
  inline NodeTransTopo::Type GetNodeType() const {
    std::unique_lock<std::mutex> lock(trans_topo_mu_);
    auto type = trans_topo_.getType();
    return type;
  }

  int SimplePushPullDefault(int key, const CArray& val);

  void InitEngine(size_t num_thread);

  void ProcessPushData(int key, const EngineTaskData& data, Engine::ReturnOnAgg& rt);

  void RequestHandle(const ps::SimpleData& recved, ps::SimpleApp* app);

  void DataHandle(const ps::KVMeta& req_meta,
                  const ps::KVPairs<char>& req_data,
                  ps::KVTrainer<char>* trainer);
};
}  // namespace constellation

#endif  // _CONSTELLATION_TRAINER_H_