#ifndef _CONSTELLATION_TRAINER_H_
#define _CONSTELLATION_TRAINER_H_

#include "./constellation_commons.h"
#include "ps/ps.h"
#include "./internal/engine.h"
#include <atomic>
#include <cmath>

namespace constellation {

// TODO: now only support default push pull
enum class RequestType { kDefaultPushPull, kDefaultInit, kRowSparsePushPull, kCompressedPushPull };

struct DataHandleType {
  RequestType requestType;
  int dtype;
};

/*!
 * Reffer to MXNet
 * Uses Cantor pairing function to generate a unique number given two numbers.
 * This number can also be inverted to find the unique pair whose Cantor value is this number.
 * Ref: https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function
 * \param requestType RequestType
 * \param dtype integer
 * \return Cantor value of arguments
 */
static int GetCommandType(RequestType type, int d) {
  int m = static_cast<int>(type);
  return (((m + d) * (m + d + 1)) / 2) + d;
};

/*!
 * Reffer to MXNet
 * Unpairs Cantor value and finds the two integers used to pair.
 * Then returns DataHandleType object with those numbers.
 * \param cmd DataHandleCommand generated by GetCommandType function
 * \return DataHandleType
 */
static DataHandleType DepairDataHandleType(int cmd) {
  int w = std::floor((std::sqrt(8 * cmd + 1) - 1) / 2);
  int t = ((w * w) + w) / 2;
  int y = cmd - t;
  int x = w - y;
  CHECK_GE(x, 0);
  CHECK_GE(y, 0);
  DataHandleType type;
  type.requestType = static_cast<RequestType>(x);
  type.dtype = y;
  return type;
};

struct CArray {
  // reffer to byteps: https://github.com/bytedance/byteps/blob/master/byteps/common/common.h
  // TODO: Add more data type
  enum class ConstelDateType {
    CONSTEL_FLOAT32 = 0,
  };
  struct DataTrunk {
    char* dptr_;
    size_t size_{0};

    DataTrunk(size_t size = 0) : size_(size) {
      if (size == 0) {
        dptr_ = nullptr;
        return;
      }
      dptr_ = new char[size];
      CHECK(dptr_);
    }
    ~DataTrunk() {
      if (dptr_) {
        delete[] dptr_;
        dptr_ = nullptr;
      }
    }
    DataTrunk(DataTrunk&&) = delete;
    DataTrunk(const DataTrunk&) = delete;
    DataTrunk& operator=(DataTrunk&&) = delete;
    DataTrunk& operator=(const DataTrunk&) = delete;
  };

  std::shared_ptr<DataTrunk> sptr_;
  int dtype;

  explicit CArray() : dtype(0), sptr_(nullptr) {}
  explicit CArray(size_t size) : dtype(0), sptr_(std::make_shared<DataTrunk>(size)) {}
  CArray(CArray&& other) = default;
  CArray(const CArray& other) = default;
  CArray& operator=(CArray&& other) = default;
  CArray& operator=(const CArray& other) = default;

  bool isNone() const {
    return sptr_ == nullptr || sptr_->dptr_ == nullptr || sptr_->size_ == 0;
  }
  inline char* data() const {
    return sptr_->dptr_;
  }
  inline size_t size() const {
    return sptr_->size_;
  }

  inline const std::shared_ptr<DataTrunk>& ptr() const {
    return sptr_;
  }

  void CopyFrom(const CArray& other) {
    // TODO:use OMP to accelerate
    if (other.data() && other.size()) {
      this->sptr_ = std::make_shared<DataTrunk>(other.size());
      memcpy(this->data(), other.data(), other.size());
      this->dtype = other.dtype;
    }
  }
  void CopyFrom(const void* data, size_t size) {
    if (this->size() != size) {
      throw "CArray::CopyFrom: size not match";
    }
    if (data && size) {
      memcpy(this->data(), data, size);
    }
  }
};

class ConstelTrainer {
 public:
  explicit ConstelTrainer() {
    ps::StartAsync(0, "ConstelTrainer");
    this->trainer_ = new ps::KVTrainer<char>(0, 0);  // app_id, customer_id
    using namespace std::placeholders;
    static_cast<ps::SimpleApp*>(this->trainer_)
        ->set_request_handle(std::bind(&ConstelTrainer::RequestHandle, this, _1, _2));
    this->trainer_->set_request_handle(std::bind(&ConstelTrainer::DataHandle, this, _1, _2, _3));
  }
  ~ConstelTrainer() {
    ps::Finalize(0, false);
    delete this->trainer_;
    this->trainer_ = nullptr;
  }

  void NotifyReady();

  void Init(std::vector<int>& keys, std::vector<CArray*>& vals_init);

  void PushPull(std::vector<int>& keys,
                std::vector<CArray>& vals_push,
                std::vector<CArray*>& vals_pull);

 private:
  /**
   * struct UpdateBuf
   * @brief store the request meta  and merged gradient
   */
  struct UpdateBuf {
    std::vector<ps::KVMeta> request_meta;
    CArray merged;
    size_t num = 0;
    bool shouldReset = false;
    void ResetUpdateBuf() {
      if(shouldReset){
        request_meta.clear();
        num = 0;
        shouldReset = false;
      }
    }
  };

  enum class TaskTypeEnum {
    kPushPull,
    kInitDefault,
  };

  struct EngineTaskData {
    UpdateBuf update_buf;
    TaskTypeEnum type;
    bool isFromRoot = false;
  };

  /**
   * \brief update_buf_ is used to store the request meta from the son(include itself) and merged
   * gradient
   */
  std::unordered_map<int, UpdateBuf> update_buf_;

  std::unordered_map<int, int> init_waiting_ts_;

  using Engine = ConstelAggEngine<EngineTaskData, int>;

  ScaleClock clock_;

  NodeTransTopo trans_topo_;

  ps::KVTrainer<char>* trainer_;

  std::atomic<bool> is_ctx_ready_{false};

  bool is_scale_ = true;

  mutable std::mutex update_buf_mu_;

  mutable std::mutex trans_topo_mu_;

  mutable std::mutex init_waiting_ts_mu_;

  Engine* engine_;

  UpdateBuf* GetUpdateBuf(int key) {
    std::lock_guard<std::mutex> lock(update_buf_mu_);
    return &update_buf_[key];
  }
  inline auto& GetNodeTransTopo() {
    std::unique_lock<std::mutex> lock(trans_topo_mu_);
    return trans_topo_;
  }
  inline auto GetNodeType() const {
    std::unique_lock<std::mutex> lock(trans_topo_mu_);
    auto type = trans_topo_.getType();
    return type;
  }

  inline bool isRootNode() const {
    auto type = GetNodeType();
    CHECK(type != NodeTransTopo::Type::kUnset);
    return type == NodeTransTopo::Type::kRoot;
  }
  inline bool isLeafNode() const {
    auto type = GetNodeType();
    CHECK(type != NodeTransTopo::Type::kUnset);
    return type == NodeTransTopo::Type::kLeaf;
  }

  int SimplePushPullDefault(int key, const CArray& val);

  void InitEngine(size_t num_thread);

  void ProcessPushData(int key, const EngineTaskData& data, Engine::ReturnOnAgg& rt);

  void RequestHandle(const ps::SimpleData& recved, ps::SimpleApp* app);

  void DataHandle(const ps::KVMeta& req_meta,
                  const ps::KVPairs<char>& req_data,
                  ps::KVTrainer<char>* trainer);
};
}  // namespace constellation

#endif  // _CONSTELLATION_TRAINER_H_