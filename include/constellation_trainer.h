#ifndef _CONSTELLATION_TRAINER_H_
#define _CONSTELLATION_TRAINER_H_

#include "./constellation_commons.h"
#include "ps/ps.h"
#include "./internal/CArray.h"

#ifdef CONS_NETWORK_AWARE
#include "clusterRM/smq.h"
#endif

#include <atomic>
#include <cmath>

namespace moniter {
class Smq;
}

namespace constellation {

template <typename Data, typename ResType>
class ConstelAggEngine;

template <typename Data, typename ResType>
class ReturnOnAgg;

// TODO: now only support default push pull
enum class RequestType {
  kDefaultPushPull,
  kDefaultInit,
  kModelSync,
  kRowSparsePushPull,
  kCompressedPushPull
};

struct DataHandleType {
  RequestType requestType;
  int dtype;
};

/*!
 * Refer to MXNet
 * Uses Cantor pairing function to generate a unique number given two numbers.
 * This number can also be inverted to find the unique pair whose Cantor value
 * is this number. Ref:
 * https://en.wikipedia.org/wiki/Pairing_function#Cantor_pairing_function
 * \param requestType RequestType
 * \param dtype integer
 * \return Cantor value of arguments
 */
static int GetCommandType(RequestType type, int d) {
  int m = static_cast<int>(type);
  return (((m + d) * (m + d + 1)) / 2) + d;
};

/*!
 * Refer to MXNet
 * Unpairs Cantor value and finds the two integers used to pair.
 * Then returns DataHandleType object with those numbers.
 * \param cmd DataHandleCommand generated by GetCommandType function
 * \return DataHandleType
 */
static DataHandleType DepairDataHandleType(int cmd) {
  int w = std::floor((std::sqrt(8 * cmd + 1) - 1) / 2);
  int t = ((w * w) + w) / 2;
  int y = cmd - t;
  int x = w - y;
  CHECK_GE(x, 0);
  CHECK_GE(y, 0);
  DataHandleType type;
  type.requestType = static_cast<RequestType>(x);
  type.dtype = y;
  return type;
};

class TimeRecoder;

class ConstelTrainer {
 public:
  explicit ConstelTrainer();
  ~ConstelTrainer();

  inline const auto& GetNodeTransTopo() const {
    std::unique_lock<std::mutex> lock(trans_topo_mu_);
    return trans_topo_;
  }
  inline uint32_t GetLocalTimestamp() const {
    return clock_.getLocalTimestamp();
  }
  inline const NodeTransTopo::Type& GetNodeType() const {
    std::unique_lock<std::mutex> lock(trans_topo_mu_);
    auto& type = trans_topo_.getType();
    return type;
  }

  inline bool isRootNode() const {
    auto type = GetNodeType();
    CHECK(type != NodeTransTopo::Type::kUnset);
    return type == NodeTransTopo::Type::kRoot;
  }
  inline bool isLeafNode() const {
    auto type = GetNodeType();
    CHECK(type != NodeTransTopo::Type::kUnset);
    return type == NodeTransTopo::Type::kLeaf;
  }

  inline int NumTrainers() const {
    return trans_topo_.num_trainers;
    // return ps::Postoffice::Get()->num_trainers();
  }

  inline int myRank() const {
    return trans_topo_.rank;
    // return ps::Postoffice::Get()->myRank();
  }

  inline int myid() const {
    return ps::Postoffice::Get()->GetMyID();
  }

  void NotifyReadyAndWait(bool need_sycn_model = false,
                          const std::vector<int> keys = {},
                          const std::vector<uint64_t> lens = {});

  bool BatchEnd(std::vector<int>* keys_to_migrate = nullptr);

  void Migrate(const std::vector<int>& keys, const std::vector<CArray>& vals);

  void Broadcast(const std::vector<int>& keys,
                 const std::vector<CArray*>& vals_init);

  void Recv(const std::vector<int>& keys, const std::vector<CArray*>& vals);

  void PushPull(const std::vector<int>& keys,
                const std::vector<CArray>& vals_push,
                const std::vector<CArray*>& vals_pull);

  bool is_scale() const {
    return is_scale_;
  }

  friend class __ConstelTrainerTest;

 private:
  /**
   * struct UpdateBuf
   * @brief store the request meta  and merged gradient
   */
  struct UpdateBuf {
    std::vector<ps::KVMeta> request_meta;
    CArray merged;
    size_t num = 0;
    bool shouldReset = false;
    void ResetUpdateBuf() {
      if (shouldReset) {
        request_meta.clear();
        num = 0;
        shouldReset = false;
      }
    }
  };

  enum class TaskTypeEnum {
    kPushPull,
    kBroadcastDefault,
  };

  struct EngineTaskData {
    UpdateBuf update_buf;
    TaskTypeEnum type;
    bool isFromRoot = false;
  };

  /**
   * \brief update_buf_ is used to store the request meta from the son(include
   * itself) and merged gradient
   */
  std::unordered_map<int, UpdateBuf> update_buf_;

  std::unordered_map<int, int> init_waiting_ts_;

  std::unordered_map<uint32_t, std::vector<std::pair<int, EngineTaskData>>>
      cached_kv_;
  std::mutex cached_kv_mu_;

  ScaleClock clock_;

  NodeTransTopo trans_topo_;

  ModelSycnConf model_sync_conf_;

  ps::KVTrainer<char>* trainer_;

  std::atomic<bool> is_ctx_ready_{false};

  std::atomic<bool> is_model_sync_{false};

  std::mutex model_sync_mu_;
  std::condition_variable model_sync_cv_;
  std::unordered_map<int, uint64_t> model_info_;
  uint64_t model_size_ = 0;
  std::vector<int>* wait_recv_keys_ = nullptr;
  std::vector<CArray*>* wait_recv_vals_ = nullptr;

  std::atomic<bool> is_scale_{true};

  mutable std::mutex update_buf_mu_;

  mutable std::mutex trans_topo_mu_;

  mutable std::mutex init_waiting_ts_mu_;

  using EngineType = ConstelAggEngine<EngineTaskData, int>;

  EngineType* engine_;

  std::shared_ptr<TimeRecoder> batch_t_;
  std::shared_ptr<WindowedBuffer<int64_t>> rtt_window_;

  UpdateBuf* GetUpdateBuf(int key) {
    std::lock_guard<std::mutex> lock(update_buf_mu_);
    return &update_buf_[key];
  }

  inline void SetNodeTransTopo(const NodeTransTopo& topo) {
    std::unique_lock<std::mutex> lock(trans_topo_mu_);
    ps::Postoffice::Get()->UpdateLocalTrans(topo.getParent(),
                                            topo.getChildren());
    trans_topo_ = topo;
  }

  void MigrateFullSlice(const std::vector<int>& path,
                        const std::vector<int>& keys,
                        const std::vector<CArray>& vals,
                        const KVSlice& kvslice);

  void MigratePartialSlice(const std::vector<int>& path,
                           const std::vector<int>& keys,
                           const std::vector<CArray>& vals,
                           const KVSlice& kvslice);

  int SimplePushPullDefault(int key, const CArray& val);

  void NotifySchedulerUpdateClock(const ClockSignalBody& body);

  void InitEngine(size_t num_thread);

  void ProcessPushData(int key,
                       const EngineTaskData& data,
                       std::shared_ptr<ReturnOnAgg<EngineTaskData, int>> rt);

  void RequestHandle(const ps::SimpleData& recved, ps::SimpleApp* app);

  void ResponseHandle(const ps::SimpleData& recved, ps::SimpleApp* app);

  void DataHandle(const ps::KVMeta& req_meta,
                  const ps::KVPairs<char>& req_data,
                  ps::KVTrainer<char>* trainer);

#ifdef CONS_NETWORK_AWARE
  std::unique_ptr<moniter::Smq> test_client_;
  std::unique_ptr<std::thread> test_client_thread_;
#endif
};
}  // namespace constellation

#endif  // _CONSTELLATION_TRAINER_H_